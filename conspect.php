<?php
Лекция №1
Преимущества ООП:
● уменьшение сложности ПО;
● повышение надежности ПО;
● возможность модификации отдельных компонентов ПО без изменения остальных его
составляющих;
● возможность повторного использования отдельных компонентов ПО .


__construct() - магический метод



$this - контекст внутри объекта
$self - контекст внутри класса(срабатывает в момент инициализации, а не в момент выполнения,
поэтому при наследовании методов внутри них self будет указывать на класс - родитель(parent)),
т . е . связывание происходит слишком рано .
Для позднего статического связывания вместо self в методах класса родителя нужно использовать static.

Константы класса задаются с помощью специального слова const. Обратите внимание, что к
константе мы обращаемся с помощью конструкции «self::», а не «$this -> », так как константа
принадлежит классу, а не объекту .

Статические методы и свойства принадлежат классу, а не его экземплярам .

Статические методы(функции) класса обращаться к ним извне без создания экземпляра класса, например:
echo MathOperations ::RangeLength(12);
К константе класса тоже можно обратиться без создания экземпляра класса с помощью :: .
echo MathOperations::CONSTANTA;

parent::статическое свойство родителя

static
Так как статические методы вызываются без создания экземпляра класса,
то псевдопеременная $this недоступна внутри статических методов .
Доступ к статическим свойствам осуществляется с помощью оператора разрешения области видимости( ::),
и к ним нельзя получить доступ через оператор объекта( ->).

class Foo
{
    public static $my_static = 'foo';

    public function staticValue()
    {
        return self ::$my_static;
    }
}
class Bar extends Foo
{
    public function fooStatic()
    {
        return parent ::$my_static;
    }
}

print $foo ::$my_static . "\n";

Внутри классов можно объявлять константы
const CONSTANT = 'value';
echo self::CONSTANT; обращение к константе внутри класса .

echo $class ::CONSTANT; обращение к константе снаружи по имени класса .


Модификаторы свойств объектов(области видимости):
public -позволяет обращаться к свойствам и методам отовсюду
private -доступно только внутри класса, недоступно даже наследникам, даже экземплярам данного класса .
protected -доступно только внутри класса и наследникам

Если не планируется расширять класс, то нужно использовать private
(при необходимости расширения класса можно будет понизить до protected).

Позднее статическое связывание сохраняет имя класса указанного в последнем "неперенаправленном вызове" .
"Перенаправленный вызов" - это статический вызов, начинающийся с self ::, parent ::, static :: .
    "Позднее связывание" - обращения через static:: будут вычисляться не по отношению к классу,
в котором вызываемый метод определён, а на основе информации в ходе исполнения .


Пример: Лекция 1, 1:55
Для позднего статического связывания(определения контекста унаследованного метода в момент его вызова)вместо self в
методах класса родителя нужно использовать static.

Чтобы избежать проблемы раннего связывания рекомендуется в методах классов вместо self всегда использовать static.
Это позволит контекст вызов методов определять в момент исполнения .

Всё это не касается унаследованных статичных переменных . В любом случае они будут иметь значение, определённое в
классе - родителе .

class B extends A дело тут не в связывании а в статике, статичная переменная принадлежит классу, но если она в методе, то у наследника будет новый метод и своя статичная х.


Лекция №2

Применим паттерн Active Record:
каждый экземпляр класса соответствует одной записи(строке) в таблице базы данных .
Свойства экземпляра класса публичны .
Методы класса не принимают аргументов, а обращаются к данным, инкапсулированным в
объекте напрямую .


При необходимости подключения большого количества файлов челез include делать это нецелесообразно .

Проблему подключения большого количества классов решает __autoload() .
В настоящее время __autoload() устарела, но существует надстройка .
Существует устаревшая функция __autoload() или её современный аналог spl_autoload_register() .

spl_autoload_register — Регистрирует заданную функцию в качестве реализации метода __autoload()

spl_autoload_register(?callable $callback = null, bool $throw = true, bool $prepend = false): bool
callback - Имя функции, реализующей метод spl_autoload() . Если null, будет зарегистрирована реализация по умолчанию .

Вместо коллбека spl_autoload_register в качестве параметра может принимать массив:
[new Autoload(), 'loadClass'] - класс автозагрузчик, метод класса автозагрузчика .


Для автозагрузки сторонней библиотеки достаточно подключить её автозагрузчик через include


Для его реализации имя класса должно совпадать с названием файла .
Для решения проблемы совпадающих имён классов(например, при подключении сторонних
библиотек) служит пространство имён: namespace.

Аналогом пространства имён в файловой системе является дерево каталогов:
файлы с одинаковыми именами можно хранить в папках с разными путями;
классы с одинаковыми именами можно хранить в разных пространствах имён .

Без указания namespace все имена классов находятся в глобальном пространстве имён .

!Для корректной работы автозагрузчика имена классов должны совпадатьс именами файлов, в которых они хранятся, а namespace должно повторять структуру каталогов.
Тогда в автозагрузчик в имени класса будет приходить путь к файлу, в котором хранится реализация класса.

Синтаксис namespace требует использовать только обратный slash: "\".
Это приводит к формированию путей вида: '../models/shop\models\Product.php'.

!Обратный slash не поддерживается Linux.

Для решения этой проблемы slash нужно перевернуть с помощью str_replace():
$className=str_replace('\\', '/', $className);

В проекте мы условились принять за корень namespace виртуальную "папкуecho echo " app, чтобы
исключить совпадение с namespace подключаемых библиотек.
Таких префиксов можно создавать неограниченное количество, например:
    medvedev\alexey\app\models
    
Для удобства работы с длинными namespace используются псевдонимы, например

use app\models\User as User;

если при этом имя класса не изменяется, то as можно опускать:

use app\models\User;

При частично совпадающих namespace можно использовать сокращённую запись:
use app\models\{User,Product};
    
В пределах файла класса объявленный namespace автоматически присоединяется к именам использующихся в коде классов. Если требуется обратиться к классу, объявленному в другом пространстве имён, то нужно указывать полный namespace.
    
Задание 1.
!preg_filter — Производит поиск и замену по регулярному выражению
    Функция preg_filter() идентична функции preg_replace() за исключением того, что возвращает только те значения (возможно, преобразованные), в которых найдено совпадение.
!preg_replace() — Выполняет поиск и замену по регулярному выражению

       Экземпляр класса Db будет единственным на всё приложение, поэтому мы принимаем его в качестве параметра
       
Выносим общий функционал в абстрактный класс Model;
В Model объявляем абстрактные методы (не требующие реализации), (например, возвращающий название таблицы), чтобы не забыть их создать в наследниках.
    
    Невозможно создать экземпляр абстрактного класса;
    Абстрактный метод должен быть переопределён в наследнике.
    
    В интерфейсах перечисляют все публичные методы класса;
    Название  интерфейса обычно начинается с I и имени соответствующего класса.
    
    Абстрактный класс создаётся для запрещения создания экземпляров класса (т.к. это бессмысленно);
    Абстрактный метод (без указания реализации) создаётся, когда он обязательно должен присутствовать в классе-наследнике (в нём и указывается реализация метода).
    Интерфейс созадаётся для перечисления публичных методов, которые должен реализовать (имплементировать) класс, без необходимости описания их функционала.
    
    В PHP запрещено множественное наследование (невозможно наследоваться сразу от нескольких классов), но можно реализовать несколько интерфейсов. В этом случае интерфейсы должны быть перечислены через запятую после слова implements.
    
    Магические методы __set() и __get() позволяют описать поведение класса при обращении к его несуществующим или закрытым полям его экземпляра (с его помощью можно запретить динамическое создание полей объекта):
    
    public function __set($field)
    {
        echo "Поле {$field} в данном объекте не существует!";
    }
    
    Также с помощью магических __set() и __get() можно создать сеттеры и геттеры
    сразу для всех полей объекта:
    
    public function __set($name)
    {
        $this->name = $name;
    }
    
    public function __get($name)
    {
        return $this->name;
    }
    
    Лекция №3
    
    DIRECTORY_SEPARATOR
    В PHP есть предопределённая константа DIRECTORY_SEPARATOR, содержащая разделитель пути. Для Windows это «\», для Linux и остальных — «/». Так как Windows понимает оба разделителя, достаточно использовать в коде разделитель Linux вместо константы.
    
    str_replace(
    array|string $search,
    array|string $replace,
    string|array $subject,
    int &$count = null
): string|array
Эта функция возвращает строку или массив, в котором все вхождения search в subject заменены на replace.
    
    Встроенные классы PHP относятся к глобальному пространству имён.
    При обращении к встроенным классам PHP нужно указывать их пространство имён: "\".
    Например:
    $db = new \PDO();
        или
    use "\echo echo ";
                    
                    Работать с mysqli - низкоуровневая библиотека;
                    В рабочих проектах необходимо использовать встроенный в PHP класс PDO, основанный на mysqli.
                    
                    
                    Подключение к MySQL
            <?php
            $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
            ?>
                
                Чтобы закрыть подключение нужно удалить объект:
                $dbh = null;
                
         //настройка, которая позволяет получить результаты в виде ассоциативного массива
        $DBH -> setAttribute(PDO::ATTR_DERAULT_FETCH_MODE, PDO::FETCH_ASSOC);    
                
            $dbh->query() использовать нежелательно, т.к. он сразу выполняется;
            
            $dbh->prepare() предпочтительнее, но без placeholders есть опасность SQL-инъекций;
            Вставлять в запрос переменные напрямую нельзя.
            
            placeholders бывают двух видов: ? и :.
            
            Плейсхолдерам можно назначить переменные:
            $dbh->bindParam(1, $name); - для безымянных плейсхолдеров (с ?).
            $dbh->bindParam(name, $name); - для именованных плейсхолдеров (с :).
                        или в виде массива
            $data = ["Caty","19", "Pari") - для безымянных плейсхолдеров.
            
            $STH = $dbh->prepare("INSERT INTO table (name, old, city) values (?,?,?)"); - готовим запрос с безымянными плейсхолдерами.
            
            PDO->prepare() возвращает объект $STH.
            
           $STH->execute($data); - на места плейсхолдеров автоматически подставятся элементы массива, храняшегося в переменной $data. 
           
           В подготовленный запрос можно будет подставлять и другие данные в виде массивов. Это повышает уровень безопасности и быстродействие.
           
           У объекта $STH есть методы fetch(), которые позволяют вернуть данные:
           $STH->fetchAll();
            
            
            $dbh->prepare() данные отправляются на сервер, но запрос не выполняется;
            
            $dbh->exequte() выполнение запроса.
            

    
    
    $DBH->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);

// PDO::FETCH_ASSOC – извлечение данных в виде ассоциативного массива.

$STH = $DBH->prepare(‘SELECT * FROM ‘products’ WHERE id = :id”);

 

$STH->setFetchMode(PDO::FETCH_CLASS, “имя класса, на основе которого будут храниться данные”);

В данном случае извлечение данных из БД происходит до вызова конструктора класса, поэтому данные обнулятся.

Чтобы этого избежать,  нужно указать параметр PDO::FETCH_PROPS_LATE.

Это приведёт к тому, что сначала будет вызван конструктор (создан объект класса, указанного в скобках), а потом извлечены данные из БД и записаны в соответствующие поля созданного объекта:

$STH->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, “имя класса, в экземпляр которого будут помещены данные, полученные из БД”);

 

 

Первый спобоб – биндинг параметров

$id = 1;

$STH->bindParam(‘:id’, $id); //биндим параметр id за переменной $id – обеспечена безопасность.

$STH->execute(); // выполняем подготовленный ранее запрос

var_dump($STH->fetch());//извлекаем данные из БД (сохранённые в объекте $STH в результате работы метода execute()?).

 

$id = 2;

$STH->bindParam(‘:id’, $id); //биндим параметр id за переменной $id – обеспечена безопасность.

$STH->execute(); // выполняем подготовленный ранее запрос

var_dump($STH->fetch());//и извлекаем данные из БД.

 

Второй способ – передача данных в подготовленный запрос с помощью ассоциативного массива

более предпочтительный

$data = [‘id’=>1];

//$STH->bindParam(‘:id’, $id);

$STH->execute( $data ); // передаём ассоциативный массив к качестве аргумента и выполняем подготовленный ранее запрос к БД.

var_dump($STH->fetch());

 
//например, есть запрос -  $sql = “SELECT * FROM ‘products’ WHERE id = :id $params = [ ‘id’=>1 ]”;
 


}

 

//вставить в index.php для тестирования и отладки класса Db

$db = new Db(); // уже есть



 

//скорректировать класс Model

 

class Model

{

 

  public function __construct()

  {

    $this->db = new Db();

  }

 

  public function getOne()

{

    $sql = “SELECT * FROM {$this->getTableName()} WHERE id = :id”;

    return $this->db->queryOne( $sql, [ ‘id’ => id] );

  }

 

  public function getAll()

{

    $sql = “SELECT * FROM {$this->getTableName()}”;

    return $this->db->queryOne( $sql);

  }
}

 

//теперь при создании новых экземпляров классов-наследников класса Db не требуется передавать параметр $db (new Db() вызывает конструктор класса Model)

//Возникла проблема: при создании новых экземпляров классов-наследников Model каждый раз создаются новые экземпляры класса Db.

//Для решения этой проблемы применим паттерн Singletone

//Добавим в класс Db

class Db

{

//после private $connection = null;

 

private static $instance = null;

public static getInstance() //статический метод позволит вызывать себя без создания экземпляра класса
{
  If ( is_null ( static::$instance ){ //используем позднее статическое связывание
      Static::instance = new static();
    }
  return $this->instance;
}
}

//наличие статического свойства и метода getInstance() позволяет не создавать поле $db в классе Model (конструктор в Model теперь тоже не нужен)

//вместо этого будем использовать Singletone

//т.к. свойства db в объектах больше нет, требуется переписать методы класса Model, на обращение к Db::getInstance(), вместо $this->db:

  public function getOne()

{

    $sql = “SELECT * FROM {$this->getTableName()} WHERE id = :id”;

    return Model::getInstance()->queryOne( $sql, [ ‘id’ => id] );

  }
  public function getAll()

{

    $sql = “SELECT * FROM {$this->getTableName()}”;

    return Model::getInstance()->queryOne( $sql);

  }

Удалить свойство $db.

 

Чтобы исключить возможность ошибочного создания дополнительных экземпляров класса Db, сделаем его конструктор приватным:

class Db {

  private function __construct();

  private function __ clone();

  private function __ wakeup();
}


Следует помнить, что в PHP7 существуют и другие методы, кроме __construct(), позволяющие создать экземпляр класса:

__clone()

__wakeup()

Поэтому их тоже нужно заприватить.

Теперь осталась единственная возможность создания экземпляра класса Db: через публичный метод getInstance()

 

1:48 Traits – трейты – куски класса (повторяющиеся блоки кода),
traits можно подключить в другие классы с помощью use.
    
    sprintf(string $format, mixed ...$values): string
Возвращает строку, созданную с использованием строки формата format.
    
    trait TSingletone
{
    private static $instance = null;

    private function __construct(){}

    private function __clone(){}

    private function __wakeup(){}

    //статический метод позволит вызывать себя без создания экземпляра класса
    public static function getInstance()
    {
        //используем позднее статическое связывание
        if (is_null(static::$instance)) {
            static::$instance = new static();
        }
        return static::$instance;
    }
}
    
    Чтобы класс превратился в Singletone, достаточно подключить в него этот трейт
    use TSingletone;
    
    Перебор полей и значений объекта:
            foreach ($this as $key=>$value)
            
    Получить имя текущего класса вместе с namespace (обычно требуется в абстрактном классе):
    static::class
        или
    get_called_class(): string - Возвращает имя класса, из которого был вызван статический метод.
    
    PDO::FETCH_CLASS: создаёт и возвращает объект запрошенного класса, присваивая значения столбцов результирующего набора именованным свойствам класса, и следом вызывает конструктор, если не задан PDO::FETCH_PROPS_LATE.
    
    Добавить элемент в ассоциативный массив:
    $params["название ключа"] = $value;

    array_keys($arr) -  возвращает числовые и строковые ключи, содержащиеся в массиве array.

    Пропустить итерацию в цикле:
    if (true) continue;