<?php
Лекция №1
Преимущества ООП:
● уменьшение сложности ПО;
● повышение надежности ПО;
● возможность модификации отдельных компонентов ПО без изменения остальных его
составляющих;
● возможность повторного использования отдельных компонентов ПО .


__construct() - магический метод



$this - контекст внутри объекта
$self - контекст внутри класса(срабатывает в момент инициализации, а не в момент выполнения,
поэтому при наследовании методов внутри них self будет указывать на класс - родитель(parent)),
т . е . связывание происходит слишком рано .
Для позднего статического связывания вместо self в методах класса родителя нужно использовать static.

Константы класса задаются с помощью специального слова const. Обратите внимание, что к
константе мы обращаемся с помощью конструкции «self::», а не «$this -> », так как константа
принадлежит классу, а не объекту .

Статические методы и свойства принадлежат классу, а не его экземплярам .

Статические методы(функции) класса обращаться к ним извне без создания экземпляра класса, например:
echo MathOperations ::RangeLength(12);
К константе класса тоже можно обратиться без создания экземпляра класса с помощью :: .
echo MathOperations::CONSTANTA;

parent::статическое свойство родителя

static
Так как статические методы вызываются без создания экземпляра класса,
то псевдопеременная $this недоступна внутри статических методов .
Доступ к статическим свойствам осуществляется с помощью оператора разрешения области видимости( ::),
и к ним нельзя получить доступ через оператор объекта( ->).

class Foo
{
    public static $my_static = 'foo';

    public function staticValue()
    {
        return self ::$my_static;
    }
}
class Bar extends Foo
{
    public function fooStatic()
    {
        return parent ::$my_static;
    }
}

print $foo ::$my_static . "\n";

Внутри классов можно объявлять константы
const CONSTANT = 'value';
echo self::CONSTANT; обращение к константе внутри класса .

echo $class ::CONSTANT; обращение к константе снаружи по имени класса .


Модификаторы свойств объектов(области видимости):
public -позволяет обращаться к свойствам и методам отовсюду
private -доступно только внутри класса, недоступно даже наследникам, даже экземплярам данного класса .
protected -доступно только внутри класса и наследникам

Если не планируется расширять класс, то нужно использовать private
(при необходимости расширения класса можно будет понизить до protected).

Позднее статическое связывание сохраняет имя класса указанного в последнем "неперенаправленном вызове" .
"Перенаправленный вызов" - это статический вызов, начинающийся с self ::, parent ::, static :: .
    "Позднее связывание" - обращения через static:: будут вычисляться не по отношению к классу,
в котором вызываемый метод определён, а на основе информации в ходе исполнения .


Пример: Лекция 1, 1:55
Для позднего статического связывания(определения контекста унаследованного метода в момент его вызова)вместо self в
методах класса родителя нужно использовать static.

Чтобы избежать проблемы раннего связывания рекомендуется в методах классов вместо self всегда использовать static.
Это позволит контекст вызов методов определять в момент исполнения .

Всё это не касается унаследованных статичных переменных . В любом случае они будут иметь значение, определённое в
классе - родителе .

class B extends A дело тут не в связывании а в статике, статичная переменная принадлежит классу, но если она в методе, то у наследника будет новый метод и своя статичная х.


Лекция №2

Применим паттерн Active Record:
каждый экземпляр класса соответствует одной записи(строке) в таблице базы данных .
Свойства экземпляра класса публичны .
Методы класса не принимают аргументов, а обращаются к данным, инкапсулированным в
объекте напрямую .


При необходимости подключения большого количества файлов челез include делать это нецелесообразно .

Проблему подключения большого количества классов решает __autoload() .
В настоящее время __autoload() устарела, но существует надстройка .
Существует устаревшая функция __autoload() или её современный аналог spl_autoload_register() .

spl_autoload_register — Регистрирует заданную функцию в качестве реализации метода __autoload()

spl_autoload_register(?callable $callback = null, bool $throw = true, bool $prepend = false): bool
callback - Имя функции, реализующей метод spl_autoload() . Если null, будет зарегистрирована реализация по умолчанию .

Вместо коллбека spl_autoload_register в качестве параметра может принимать массив:
[new Autoload(), 'loadClass'] - класс автозагрузчик, метод класса автозагрузчика .


Для автозагрузки сторонней библиотеки достаточно подключить её автозагрузчик через include


Для его реализации имя класса должно совпадать с названием файла .
Для решения проблемы совпадающих имён классов(например, при подключении сторонних
библиотек) служит пространство имён: namespace.

Аналогом пространства имён в файловой системе является дерево каталогов:
файлы с одинаковыми именами можно хранить в папках с разными путями;
классы с одинаковыми именами можно хранить в разных пространствах имён .

Без указания namespace все имена классов находятся в глобальном пространстве имён .

!Для корректной работы автозагрузчика имена классов должны совпадатьс именами файлов, в которых они хранятся, а namespace должно повторять структуру каталогов.
Тогда в автозагрузчик в имени класса будет приходить путь к файлу, в котором хранится реализация класса.

Синтаксис namespace требует использовать только обратный slash: "\".
Это приводит к формированию путей вида: '../models/shop\models\Product.php'.

!Обратный slash не поддерживается Linux.

Для решения этой проблемы slash нужно перевернуть с помощью str_replace():
$className=str_replace('\\', '/', $className);

В проекте мы условились принять за корень namespace виртуальную "папкуecho echo " app, чтобы
исключить совпадение с namespace подключаемых библиотек.
Таких префиксов можно создавать неограниченное количество, например:
    medvedev\alexey\app\models
    
Для удобства работы с длинными namespace используются псевдонимы, например

use app\models\User as User;

если при этом имя класса не изменяется, то as можно опускать:

use app\models\User;

При частично совпадающих namespace можно использовать сокращённую запись:
use app\models\{User,Product};
    
В пределах файла класса объявленный namespace автоматически присоединяется к именам использующихся в коде классов. Если требуется обратиться к классу, объявленному в другом пространстве имён, то нужно указывать полный namespace.
    
Задание 1.
!preg_filter — Производит поиск и замену по регулярному выражению
    Функция preg_filter() идентична функции preg_replace() за исключением того, что возвращает только те значения (возможно, преобразованные), в которых найдено совпадение.
!preg_replace() — Выполняет поиск и замену по регулярному выражению

       Экземпляр класса Db будет единственным на всё приложение, поэтому мы принимаем его в качестве параметра
       
Выносим общий функционал в абстрактный класс Model;
В Model объявляем абстрактные методы (не требующие реализации), (например, возвращающий название таблицы), чтобы не забыть их создать в наследниках.
    
    Невозможно создать экземпляр абстрактного класса;
    Абстрактный метод должен быть переопределён в наследнике.
    
    В интерфейсах перечисляют все публичные методы класса;
    Название  интерфейса обычно начинается с I и имени соответствующего класса.
    
    Абстрактный класс создаётся для запрещения создания экземпляров класса (т.к. это бессмысленно);
    Абстрактный метод (без указания реализации) создаётся, когда он обязательно должен присутствовать в классе-наследнике (в нём и указывается реализация метода).
    Интерфейс созадаётся для перечисления публичных методов, которые должен реализовать (имплементировать) класс, без необходимости описания их функционала.
    
    В PHP запрещено множественное наследование (невозможно наследоваться сразу от нескольких классов), но можно реализовать несколько интерфейсов. В этом случае интерфейсы должны быть перечислены через запятую после слова implements.
    
    Магические методы __set() и __get() позволяют описать поведение класса при обращении к его несуществующим или закрытым полям его экземпляра (с его помощью можно запретить динамическое создание полей объекта):
    
    public function __set($field)
    {
        echo "Поле {$field} в данном объекте не существует!";
    }
    
    Также с помощью магических __set() и __get() можно создать сеттеры и геттеры
    сразу для всех полей объекта:
    
    public function __set($name)
    {
        $this->name = $name;
    }
    
    public function __get($name)
    {
        return $this->name;
    }